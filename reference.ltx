\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\bfseries\color{blue},
    commentstyle=\itshape\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true
}

\begin{document}

\section*{Math for Competitive Programming}
Mathematics forms the backbone of many competitive programming problems. It enables problem-solving with proofs, optimizations, and accurate computations.

\section*{Key Concepts}

\subsection*{Modulo Arithmetic}
Common in programming contests to keep numbers manageable.

\[
(a + b) \bmod m = ((a \bmod m) + (b \bmod m)) \bmod m
\]

\[
(a - b) \bmod m = ((a \bmod m) - (b \bmod m) + m) \bmod m
\]

\[
(a \times b) \bmod m = ((a \bmod m) \times (b \bmod m)) \bmod m
\]

\textbf{Modular Inverse}: If \(a\) and \(m\) are coprime, the modular inverse of \(a \bmod m\) is \(a^{m-2} \bmod m\) (using Fermat's Little Theorem).

\subsection*{Greatest Common Divisor (GCD) and Least Common Multiple (LCM)}
Efficient computation using Euclid's Algorithm:

\begin{lstlisting}
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a
\end{lstlisting}

LCM formula:
\[
\text{lcm}(a, b) = \frac{a \times b}{\text{gcd}(a, b)}
\]

\subsection*{Prime Numbers and Sieves}
Efficient generation of prime numbers up to \(N\) using the Sieve of Eratosthenes:

\begin{lstlisting}
def sieve(n):
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
    return [i for i, prime in enumerate(is_prime) if prime]
\end{lstlisting}

\subsection*{Fast Exponentiation}
Efficiently compute \(a^b \bmod m\) in \(O(\log b)\):

\begin{lstlisting}
def power(a, b, m):
    result = 1
    while b:
        if b % 2:
            result = (result * a) % m
        a = (a * a) % m
        b //= 2
    return result
\end{lstlisting}

\subsection*{Factorials and Binomial Coefficients}
Precompute factorials and modular inverses for fast binomial coefficient computation:
\[
\binom{n}{k} = \frac{n!}{k!(n-k)!} \bmod m
\]

Precomputing:

\begin{lstlisting}
def precompute_factorials(n, m):
    fact = [1] * (n + 1)
    for i in range(2, n + 1):
        fact[i] = (fact[i - 1] * i) % m
    return fact
\end{lstlisting}

\subsection*{Number Theory}
\textbf{Divisors}: For a number \(n\), its divisors can be found in \(O(\sqrt{n})\).

\textbf{Euler's Totient Function}: Counts integers coprime to \(n\) and is calculated using:
\[
\phi(n) = n \times \prod_{p \text{ prime dividing } n} \left(1 - \frac{1}{p}\right)
\]

\end{document}
